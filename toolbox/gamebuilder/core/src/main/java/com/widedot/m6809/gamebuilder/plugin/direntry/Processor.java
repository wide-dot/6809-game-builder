package com.widedot.m6809.gamebuilder.plugin.direntry;

import java.io.File;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.configuration2.tree.ImmutableNode;

import com.widedot.m6809.gamebuilder.Settings;
import com.widedot.m6809.gamebuilder.plugin.direntry.format.LinkData;
import com.widedot.m6809.gamebuilder.pluginloader.Plugins;
import com.widedot.m6809.gamebuilder.spi.ObjectFactory;
import com.widedot.m6809.gamebuilder.spi.ObjectPluginInterface;
import com.widedot.m6809.gamebuilder.spi.DefaultFactory;
import com.widedot.m6809.gamebuilder.spi.DefaultPluginInterface;
import com.widedot.m6809.gamebuilder.spi.ObjectDataInterface;
import com.widedot.m6809.gamebuilder.spi.configuration.Attribute;
import com.widedot.m6809.gamebuilder.spi.configuration.Defaults;
import com.widedot.m6809.gamebuilder.spi.configuration.Defines;
import com.widedot.m6809.gamebuilder.spi.media.DirEntry;
import com.widedot.m6809.gamebuilder.spi.media.MediaDataInterface;
import com.widedot.m6809.util.FileUtil;
import com.widedot.m6809.util.zx0.Compressor;
import com.widedot.m6809.util.zx0.Optimizer;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Processor {
	
//	loader direntry for a file (8, 16 or 24 bytes):
//  -----------------------------------------------------------------------------------------------
//	[0] [0]                    - [compression 0:none, 1:packed] [load time linker 0:no, 1:yes]
//	[00 0000] [0000 0000]      - [uncompressed file size -1]
//	[0000 000] [0] [0000 0000] - [track 0-128] [face 0-1] [sector 0-255]
//	[0000 0000] [0000 0000]    - [bytes in first sector] [start offset in first sector (0: no sector)] ($ff00 : empty file)
//	[0000 0000]                - [nb sectors]
//	[0000 0000]                - [bytes in last sector (0: no sector)]
//
//	Option (8 bytes) - compression
//	[0000 0000 0000 0000] - [offset to compressed data]
//	[0000 0000] [0000 0000] [0000 0000] [0000 0000] [0000 0000] [0000 0000] - [6x delta bytes]
//	
//  start >>           |------------------| compressed data
//  |---------------------------------|     decompressed data
//  <------------------>              <--->
//        offset                      delta	
//
//	Option (8 bytes) - load time linker data
//	[0000 0000] [0000 0000]    - [byte size of linker data]
//	[0000 000] [0] [0000 0000] - [track 0-128] [face 0-1] [sector 0-255]
//	[0000 0000] [0000 0000]    - [bytes in first sector] [start offset in first sector (0: no sector)]
//	[0000 0000]                - [nb sectors]
//	[0000 0000]                - [bytes in last sector (0: no sector)]
//
//	ids to direntries are generated by blocks of 8 bytes :
//	ex :
//	file.a equ 0 ; no compression, no load time link => 8  bytes = 1 blocks
//	file.b equ 1 ;    compression, no load time link => 16 bytes = 2 blocks
//	file.c equ 3 ;    compression,    load time link => 24 bytes = 3 blocks
//	file.d equ 6
//	...
	
	public static final String ZX0 = "zx0";
	
	public static void run(ImmutableNode node, String path, Defaults defaults, Defines defines, MediaDataInterface media) throws Exception {
    	
		log.debug("Processing direntry ...");
		
		String name = Attribute.getString(node, defaults, "name", "direntry.name");
		String section = Attribute.getString(node, defaults, "section", "direntry.section");
		String codec = Attribute.getStringOpt(node, defaults, "codec", "direntry.codec");
		String linkSection = Attribute.getStringOpt(node, defaults, "loadtimelink", "direntry.linksection");
		boolean loadtimelink = (linkSection!=null?true:false);
		int maxsize = Attribute.getInteger(node, defaults, "maxsize", "directory.maxsize", Integer.MAX_VALUE);
		String gensymbols = Attribute.getStringOpt(node, defaults, "gensymbols", "direntry.gensymbols");
		String gensymbolsex = Attribute.getStringOpt(node, defaults, "gensymbolsex", "direntry.gensymbolsex");
		
		// generate symbols file
		if (gensymbols != null) {
			int id = 0;
			gensymbols = path + File.separator + gensymbols;
			Files.createDirectories(Paths.get(FileUtil.getDir(gensymbols)));
			FileWriter writer = new FileWriter(gensymbols);
			for (DirEntry de : media.getDirEntries()) {
				writer.write(de.name + " equ " + id + System.lineSeparator());
				id += de.data.length/8; // each id is an index to 8 bytes
			}
			// current entry pre-generation
			writer.write(name + " equ " + id + System.lineSeparator());
			writer.close();
		}
		
		// generate exported symbols file
		if (gensymbolsex != null) {
			int id = 0;
			gensymbolsex = path + File.separator + gensymbolsex;
			Files.createDirectories(Paths.get(FileUtil.getDir(gensymbolsex)));
			FileWriter writer = new FileWriter(gensymbolsex);
			for (DirEntry de : media.getDirEntries()) {
				writer.write(de.name + " equ " + id + System.lineSeparator());
				writer.write(" EXPORT " + de.name + System.lineSeparator());
				id += de.data.length/8; // each id is an index to 8 bytes
			}
			// current entry pre-generation
			writer.write(name + " equ " + id + System.lineSeparator());
			writer.write(" EXPORT " + name + System.lineSeparator());
			writer.close();
		}
		
		// binary data
		List<ObjectDataInterface> objects = new ArrayList<ObjectDataInterface>();
		
   		// instanciate plugins
		DefaultFactory defaultFactory;
		ObjectFactory objectFactory;
		
		// instanciate local definitions
		Defaults localDefaults = new Defaults(defaults.values);
		Defines localDefines = new Defines(defines.values);
		
		for (ImmutableNode child : node.getChildren()) {
			String plugin = child.getNodeName();
		
			defaultFactory = Plugins.getDefaultFactory(plugin);
			objectFactory = Plugins.getObjectFactory(plugin);
		    
	        if (defaultFactory == null && objectFactory == null) {
	        	throw new Exception("Unknown Plugin: " + plugin);   	
	        }
		    
	        if (defaultFactory != null) {
			    final DefaultPluginInterface processor = defaultFactory.build();
			    log.debug("Running plugin: {}", defaultFactory.name());
			    processor.run(child, path, localDefaults, localDefines);
			    defines.publish(localDefines);
	        }
	        
	        if (objectFactory != null) {
			    final ObjectPluginInterface processor = objectFactory.build();
			    log.debug("Running plugin: {}", objectFactory.name());
			    objects.add(processor.getObject(child, path, localDefaults, localDefines));
			    defines.publish(localDefines);
	        }
    	}

		// init direntry
		byte[] direntry = new byte[24];
		
		// merge all binaries
		int length = 0;
		for (ObjectDataInterface obj : objects) {
			length += obj.getBytes().length;
		}
		
	    if (length > maxsize) {
			String m = "data size " + length + " is over maxsize: " + maxsize;
			log.error(m);
			throw new Exception(m);
	    }
		
		byte[] bin = new byte[length];
		
		int o = 0;
		for (ObjectDataInterface obj : objects) {
			byte[] sbin = obj.getBytes();
			for (int i=0; i< sbin.length; i++) {
				bin[o++] = sbin[i];
			}
		}		
		
		// apply codec
		boolean compress = false;
	    int maxdelta = Integer.parseInt(Settings.values.get("direntry.zx0.delta"));
		if (codec != null && bin.length > 0) {
			
			if (codec.equals(ZX0)) {
				
				if (length > maxdelta) {
				
					log.debug("Compress data with zx0");
					int[] delta = { 0 };				
					
					// prepare data, shorten by n bytes (maxdelta)
					byte[] sbin = new byte[bin.length-maxdelta];
					System.arraycopy(bin, 0, sbin, 0, sbin.length);
					
					// compress the shortened data
					byte[] cbin = new Compressor().compress(new Optimizer().optimize(sbin, 0, maxsize, 4, false), bin, 0, false, false, delta);
					log.debug("Original size: {}+{}, Packed size: {}, Delta: {}", bin.length-maxdelta, maxdelta, cbin.length, delta[0]);
					
					// automatic selection of compressed or uncompressed data
					if (delta[0] > maxdelta) {
						log.warn("Skip compression: delta ({}) is higher than max delta.", delta[0]);
						
					} else if (bin.length <= cbin.length+maxdelta) {
						log.warn("Skip compression: compressed data size is bigger or equal to original size.");
						
					} else {
										
						// build direntry data (compression bloc)
						int offset = bin.length-cbin.length;
						direntry[8] = (byte) ((offset >>8) & 0xff);
						direntry[9] = (byte) (offset & 0xff);
						
						// copy delta bytes
						System.arraycopy(bin, bin.length-maxdelta, direntry, 10, maxdelta);
						
						bin = cbin;
						compress = true;
					}
				} else {
					log.warn("Skip compression: data size is lower or equal to max delta bytes");
				}
			}
		}
				
		// write file to media
	    byte[] dataDiskLocation = media.cwrite(section, bin);
	    
		// build direntry data
	    int i = 0;
		if (compress)     direntry[i] = (byte) (direntry[i] | 0b10000000);
		if (loadtimelink) direntry[i] = (byte) (direntry[i] | 0b01000000);
		direntry[i] = (byte) (direntry[i] | (((bin.length-1) >> 8) & 0b00111111)); // uncompressed file size -1 (max 0x4000 bytes) HIGH BYTE
		i++;
		
		direntry[i++] = (byte) (direntry[i] | ((bin.length-1) & 0xff)); // uncompressed file size -1 (max 0x4000 bytes) LOW BYTE
		
		System.arraycopy(dataDiskLocation, 0, direntry, i, 6);
		i += 6;
		
		if (compress) i += 8;
		
		if (loadtimelink) {
			
			// aggregate all link data
			LinkData linkdata = new LinkData();
			for (ObjectDataInterface obj : objects) {
				linkdata.add(obj);
			}
			linkdata.process();
		    byte[] linkDiskLocation = media.cwrite(linkSection, linkdata.data);
		    
			direntry[i++] = (byte)((linkdata.data.length >> 8) & 0xff);
			direntry[i++] = (byte)(linkdata.data.length & 0xff);
			
			System.arraycopy(linkDiskLocation, 0, direntry, i, 6);
			i += 6;
		}
			
		byte[] sizedDirentry = Arrays.copyOf(direntry, i);
	    media.addDirEntry(new DirEntry(name, sizedDirentry));
		
		log.debug("End of processing direntry");
	}
	
}
